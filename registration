#!/bin/bash

# Dati in ingresso alla function: 
# input1,mask1 indica timepoint REFERENCE
# input2, mask2 indica timepoint FOLLOW-UP

input1_T1=$1
input2_T1=$2
input1_FLAIR=$3
input2_FLAIR=$4
mask1=$5
mask2=$6
output=$7

cd $output

# Oriento le FLAIR in modo che coincidano con le T1 ottenute in uscita da sienapd
#fslreorient2std $input1_FLAIR FLAIR_baseline.nii.gz
#fslreorient2std $input2_FLAIR FLAIR_followup.nii.gz

# Portare le immagini T1-weighted nello spazio halfway 
#sienapd $input1_T1 $input2_T1 -o $output -d -r1 $mask1 -r2 $mask2

#A=A.nii.gz # T1 baseline 
#B=B.nii.gz # T1 follow-up
#A_brain_mask=A_brain_mask.nii.gz
#B_brain_mask=B_brain_mask.nii.gz

# Coregistrare l'immagini FLAIR all'immagini T1-weighted (REFERENCE)
#antsRegistration -d 3 --float 0 -o [matrice_ref,FLAIR_to_T1_baseline.nii.gz] -n Linear -u 0 -w [0.005,0.995] -r [$A,FLAIR_baseline.nii.gz,1] -t Rigid[0.1] -m MI[$A,FLAIR_baseline.nii.gz,1,32,Regular,0.25] -c [1000x500x250x100,1e-6,10] -f 8x4x2x1 -s 3x2x1x0vox -t Affine[0.1] -m MI[$A,FLAIR_baseline.nii.gz,1,32,Regular,0.25] -c [1000x500x250x100,1e-6,10] -f 8x4x2x1 -s 3x2x1x0vox 

# Brain Extraction della FLAIR baseline coregistrata
#fslmaths FLAIR_to_T1_baseline.nii.gz -mas $A_brain_mask FLAIR_to_T1_baseline_brain.nii.gz

# Coregistrare l'immagini FLAIR all'immagini T1-weighted (FOLLOW-UP)
#antsRegistration -d 3 --float 0 -o [matrice_fol,FLAIR_to_T1_fol.nii.gz] -n Linear -u 0 -w [0.005,0.995] -r [$B,FLAIR_followup.nii.gz,1] -t Rigid[0.1] -m MI[$B,FLAIR_followup.nii.gz,1,32,Regular,0.25] -c [1000x500x250x100,1e-6,10] -f 8x4x2x1 -s 3x2x1x0vox -t Affine[0.1] -m MI[$B,FLAIR_followup.nii.gz,1,32,Regular,0.25] -c [1000x500x250x100,1e-6,10] -f 8x4x2x1 -s 3x2x1x0vox 

# Brain Extraction della FLAIR follow-up coregistrata
#fslmaths FLAIR_to_T1_fol.nii.gz -mas $B_brain_mask FLAIR_to_T1_fol_brain.nii.gz

# Applicare c3d_affine per convertire le immagini halfway da FSL a RAS (ANTs)
# Utilizzo A e B (reoriented) che sono rispettivamente le immagini T1 reference e T1 follow-up
#c3d_affine_tool -ref A.nii.gz -src A.nii.gz A_halfwayto_B.mat -fsl2ras -oitk A_halfwayto_B_ANTs.mat
#c3d_affine_tool -ref A.nii.gz -src B.nii.gz B_halfwayto_A.mat -fsl2ras -oitk B_halfwayto_A_ANTs.mat 

# Applico le trasformazioni ottenute con c3d alle T1 e FLAIR di partenza per confrontarle con le halfway
#antsApplyTransforms -d 3 --float 0 -i A.nii.gz -r A.nii.gz -o T1_A_halfwayto_B_ANTs.nii.gz -n Linear -t A_halfwayto_B_ANTs.mat
#antsApplyTransforms -d 3 --float 0 -i B.nii.gz -r A.nii.gz -o T1_B_halfwayto_A_ANTs.nii.gz -n Linear -t B_halfwayto_A_ANTs.mat
#antsApplyTransforms -d 3 --float 0 -i FLAIR_to_T1_baseline.nii.gz -r FLAIR_to_T1_baseline.nii.gz -o FLAIR_A_halfwayto_B_ANTs.nii.gz -n Linear -t A_halfwayto_B_ANTs.mat
#antsApplyTransforms -d 3 --float 0 -i FLAIR_to_T1_fol.nii.gz -r FLAIR_to_T1_baseline.nii.gz -o FLAIR_B_halfwayto_A_ANTs.nii.gz -n Linear -t B_halfwayto_A_ANTs.mat

######## ANTs Registration Syn #########
fixed_T1=A_brain.nii.gz
moved_T1=B_brain.nii.gz
fixed_FLAIR=FLAIR_to_T1_baseline_brain.nii.gz
moved_FLAIR=FLAIR_to_T1_fol_brain.nii.gz

antsRegistration -d 3 --float 0 -o [matrice_T1,image_reg_T1.nii.gz] -n Linear -w [0.005,0.995] -u 0 -r B_halfwayto_A_ANTs.mat -q A_halfwayto_B_ANTs.mat -t Syn[0.1,3,0] -m CC[$fixed_T1,$moved_T1,1,4] -m CC[$fixed_FLAIR,$moved_FLAIR,1,4] -c [100x70x50x20,1e-6,20] -f 8x4x2x1 -s 3x2x1x0vox 
#antsRegistration -d 3 --float 0 -o [matrice_T1,image_reg_T1.nii.gz] -n Linear -w [0.005,0.995] -u 0 -r B_halfwayto_A_ANTs.mat -q A_halfwayto_B_ANTs.mat -t Rigid[0.1] -m MI[$fixed_T1,$moved_T1,1,32,Regular,0.25] -m MI[$fixed_FLAIR,$moved_FLAIR,1,32,Regular,0.25] -c [1,1e-6,20] -f 8 -s 0vox -v 1

#### Jacobian Determinant Image ####
CreateJacobianDeterminantImage 3 matrice_T11Warp.nii.gz image_detJ.nii.gz
#mkdir Jacobian_output
mv image_detJ.nii.gz $output/Jacobian_output/


